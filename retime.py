import util
import argparse
from itertools import combinations

parser = argparse.ArgumentParser(
    description="Sync transcript with Youtube autogenerated subtitles.")
parser.add_argument("transcript", help="Input transcript file")
parser.add_argument("subtitle", help="Input subtitle.json file")
parser.add_argument("output", help="Output file")
parser.add_argument("--max-shift", nargs="?", default=0.05, type=float,
                    help="Maximum percentage to move a sentence in the subtitles")
parser.add_argument('--fill-space', action='store_true',
                    help="Extend captions to fill all empty time")
parser.add_argument('--nltk-parse', action='store_true',
                    help="Split transcript file by sentences instead of by newlines")
args = parser.parse_args()

if args.nltk_parse:
    transcript = util.loadTranscriptNLTK(args.transcript)
else:
    transcript = util.loadTranscript(args.transcript)
subtitles = util.loadAutomaticSubs(args.subtitle)

synchronized = []
for s in range(len(transcript)):

    position = s / len(transcript)

    sentence = transcript[s]
    words = util.toWords(sentence)

    # search for all matching words in the automatic subtitles
    matches = []
    search_start = int(util.clip(position - args.max_shift) * len(subtitles))
    search_end = int(util.clip(position + args.max_shift) * len(subtitles))
    for auto in subtitles[search_start:search_end]:
        for word in words:
            if word == auto.text:
                matches.append(auto)
    matches.sort(key=lambda x: x.time)

    # look through the matched words to find the closest matching sequence
    possible_slices = [words[s:e]
                       for s, e in combinations(range(len(words) + 1), 2)]
    possible_slices.sort(key=len, reverse=True)
    sequences = []
    for slice in possible_slices:
        n = len(slice)
        for i in range(len(matches) - n + 1):
            found = all([slice[j] == matches[i + j].text for j in range(n)])
            if found:
                match_range = matches[i:i + n]
                sequences.append(util.Match(
                    match_range[0].time, match_range[-1].time, len(match_range) / len(words)))

    synchronized.append(util.Sentence(sentence, sequences, s))

synchronized.sort(
    key=lambda x: x.matches[0].confidence if len(x.matches) else 0, reverse=True)
captions = []
failed = []
for sentence in synchronized:
    succeeded = False
    for match in sentence.matches:
        conflict = False
        for caption in captions:
            # overlapping with another existing, better caption?
            if caption.start <= match.start <= caption.end or \
               caption.start <= match.end <= caption.end:
                conflict = True
            # wrong order?
            if match.start < caption.start and sentence.index > caption.index or \
               match.start > caption.start and sentence.index < caption.index:
                conflict = True
        if not conflict:
            succeeded = True
            captions.append(util.Caption(match.start, match.end,
                            sentence.text, match.confidence, sentence.index))
            break
    if not succeeded:
        failed.append(sentence)
captions.sort(key=lambda x: x.start)

failed.sort(key=lambda x: x.index)
for fail in failed:
    print("Guessing for: {:003} {}".format(fail.index, fail.text))

    # is this the first/last caption?
    if fail.index == 0:
        fail.start = 0
        fail.end = captions[0].start
        captions.insert(0, fail)
        continue
    if fail.index == len(transcript) - 1:
        fail.start = captions[-1].end
        fail.end = captions[-1].end + 1000
        captions.append(fail)
        continue

    # see if there's any space between its surrounding indexes
    for c in range(1, len(captions)):
        next = captions[c]
        prev = captions[c - 1]
        if prev.index < fail.index < next.index:
            open = next.start - prev.end
            use = open // (next.index - prev.index + 1)
            fail.start = prev.end + use * (fail.index - prev.index - 1)
            fail.end = fail.start + use
            captions.insert(c, fail)
            break

if args.fill_space:
    for c in range(len(captions) - 1):
        captions[c].end = captions[c + 1].start

print("Synchronized {:0.2f}% of captions.".format(
    (1 - (len(failed) / len(transcript))) * 100))

util.writeCaptions(captions, args.output)
